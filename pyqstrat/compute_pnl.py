# $$_ Lines starting with # $$_* autogenerated by jup_mini. Do not modify these
# $$_markdown
# # PNL Calculator
# ## Purpose
# cython code for calculating pnl faster
# 

# $$_end_markdown
# $$_code
# $$_ %load_ext Cython
# $$_end_code
# $$_code
# $$_ %%cython --force --compile-args=-Wno-parentheses-equality
# distutils: language = c++
# distutils: define_macros=NPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION
cimport cython
cimport numpy as np
import numpy as np
from cython.cimports.libc import abs as cabs
from libc.stdlib cimport malloc, free
from cython.operator cimport dereference as deref


cdef long sign(long val):
    return (0 < val) - (val < 0)


cdef struct Trade:
    long qty
    double price

    
cdef struct TradeVec:
    Py_ssize_t _start_idx
    Py_ssize_t size
    Trade* _trades
    
cdef void push_back(TradeVec& self, const Trade& trade) except *:
    self.size += 1
    cdef idx = self._start_idx + self.size - 1
    # if idx < 0:
    #    raise RuntimeError(f'invalid idx: {idx}')
    self._trades[idx] = Trade(trade.qty, trade.price)

cdef void pop_front(TradeVec& self) except *:
    self._start_idx += 1
    self.size -= 1
    # if self.size < 0:
    #    raise RuntimeError('size < 0')

cdef Trade* at(const TradeVec& self, int i) except *:
    return &self._trades[self._start_idx + i]

cdef TradeVec create(const long[::1]& qtys, const double[::1]& prices, int extra_capacity) except *:
    cdef Trade* trades = <Trade *>malloc((qtys.shape[0] + extra_capacity) * sizeof(Trade))
    cdef Py_ssize_t i 
    cdef Py_ssize_t size = 0
    for i in range(qtys.shape[0]):
        trades[i] = Trade(qtys[i], prices[i])
        size += 1
    return TradeVec(_start_idx=0, size=size, _trades=trades)

cdef dealloc(TradeVec& self):
    free(self._trades)
    
cdef struct TradePNLResult:
    TradeVec tradevec
    double realized
    
# cdef print_tv(const TradeVec& tradevec):
#     for i in range(tradevec.size):
#         print(f'{deref(at(tradevec, i)).qty} {deref(at(tradevec, i)).price}')

cdef double net_trade(Trade& trade, Trade& position):
    cdef long abs_tqty
    cdef long abs_pqty
    cdef long txn_qty
    abs_tqty = cabs(trade.qty)
    abs_pqty = cabs(position.qty)
    txn_qty = trade.qty if abs_tqty <= abs_pqty else -position.qty
    cdef double realized = txn_qty * (position.price - trade.price)
    position.qty += txn_qty
    trade.qty -= txn_qty
    return realized

@cython.boundscheck(False)  # Deactivate bounds checking
@cython.wraparound(False)   # Deactivate negative indexing.
cpdef calc_trade_pnl(
    long[::1] open_qtys, 
    double[::1] open_prices, 
    long[::1] new_qtys, 
    double[::1] new_prices, 
    double multiplier) except *:
    
    cdef TradeVec trades = create(new_qtys, new_prices, 0)
    cdef TradeVec positions = create(open_qtys, open_prices, new_qtys.shape[0])
            
    cdef Trade* trade
    cdef Trade* position
    cdef long trade_qty
    cdef long pos_qty
    
    cdef double realized = 0
    while True:
        if not trades.size: break
        trade = at(trades, 0)
        trade_qty = deref(trade).qty
             
        if not positions.size:  # no positions, so add the trade
            push_back(positions, deref(trade))
            pop_front(trades)
            continue
            
        position = at(positions, 0)
        pos_qty = deref(position).qty
        
        if sign(trade_qty) == sign(pos_qty):
            push_back(positions, deref(trade))
            pop_front(trades)
            continue
             
        realized += net_trade(deref(position), deref(trade))
        if deref(position).qty == 0:
            pop_front(positions)
        if deref(trade).qty == 0:
            pop_front(trades)
    cdef np.ndarray[long, ndim=1] _open_qtys = np.empty(positions.size, dtype=int)
    cdef np.ndarray[double, ndim=1] _open_prices = np.empty(positions.size, dtype=float)
    for i in range(positions.size):
        _trade = at(positions, i)
        _open_qtys[i] = deref(_trade).qty
        _open_prices[i] = deref(_trade).price
    dealloc(positions)
    dealloc(trades)
    return _open_qtys, _open_prices, realized * multiplier
# $$_end_code
# $$_code
def test_calc_trade_pnl():
    pos = [(15, 6.), (8, 5.)]
    trades = [[(10, 8.), (-5, 7.)],
              [(-10, 8.), (-5, 7.)],
              [(-20, 8.), (-5, 7.)]]
    open_qtys = np.array(list(zip(*pos))[0])
    open_prices = np.array(list(zip(*pos))[1])

    for _trades in trades:
        new_qtys = np.array(list(zip(*_trades))[0])
        new_prices = np.array(list(zip(*_trades))[1])
        print(calc_trade_pnl(open_qtys, open_prices, new_qtys, new_prices, 100.))
        
    trades = [[(-8, 10.), (9, 11.), (-4, 6.)],
              [(3, 51.), (10, 50.), (-5, 45.)],
              list(zip(
                  np.array([-58, -5, -5, 6, -8, 5, 5, -5, 19, 7, 5, -5, 39], dtype=int), 
                  np.array([2080, 2075.25, 2070.75, 2076, 2066.75, 2069.25, 2074.75, 
                            2069.75, 2087.25, 2097.25, 2106, 2088.25, 2085.25], dtype=float)))]
    open_qtys = np.empty(0, dtype=int)
    open_prices = np.empty(0, dtype=float)

    for _trades in trades:
        new_qtys = np.array(list(zip(*_trades))[0])
        new_prices = np.array(list(zip(*_trades))[1])
        # print(f'positions: {open_qtys} {open_prices} trades: {new_qtys} {new_prices}')
        # print(calc_trade_pnl(open_qtys, open_prices, new_qtys, new_prices, 100.))
        

# $$_end_code
# $$_code
import pstats, cProfile
from pstats import SortKey
import io

import pyximport
pyximport.install()

import compute_pnl

pr = cProfile.Profile(timeunit=0.001)
pr.enable()


pr.runctx("compute_pnl.test_calc_trade_pnl()", globals(), locals())

s = io.StringIO()
sortby = SortKey.CUMULATIVE
ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
ps.print_stats()
print(s.getvalue())

#s = pstats.Stats("Profile.prof")
#ps.strip_dirs().sort_stats(SortKey.CUMULATIVE).print_stats()

# import cProfile, pstats, io
# from pstats import SortKey
# pr = cProfile.Profile()
# pr.enable()
# # ... do something ...
# pr.disable()
# s = io.StringIO()
# sortby = SortKey.CUMULATIVE
# ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
# ps.print_stats()
# print(s.getvalue())
# $$_end_code
# $$_code
[(15, 6.), (8, 5.)] * 10
# $$_end_code
