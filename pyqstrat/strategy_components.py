# $$_ Lines starting with # $$_* autogenerated by jup_mini. Do not modify these
# $$_markdown
# # Strategy Components
# ## Purpose
# Helper components to build strategies with common use cases like VWAP entry and exit, and finite risk 
# $$_end_markdown
# $$_code
# $$_ %%checkall
import numpy as np
import pandas as pd
import pyqstrat as pq
from dataclasses import dataclass
import math
from types import SimpleNamespace
from typing import Sequence, Callable
from pyqstrat.account import Account
from pyqstrat.pq_types import Contract, ContractGroup, Trade, Order
from pyqstrat.pq_types import MarketOrder, LimitOrder, TimeInForce, ReasonCode
from pyqstrat.strategy import PriceFunctionType, StrategyContextType
from pyqstrat.pq_utils import assert_, get_child_logger, np_indexof_sorted


_logger = get_child_logger(__name__)


@dataclass
class VectorIndicator:
    '''
    An indicator created from a vector
    Args:
        vector: Vector with indicator values. Must be the same length as strategy timestamps 
    '''
    vector: np.ndarray
        
    def __call__(self,
                 contract_group: ContractGroup, 
                 timestamps: np.ndarray, 
                 indicator_values: SimpleNamespace,
                 context: StrategyContextType) -> np.ndarray:
        return self.vector


@dataclass
class VectorSignal:
    '''
    A signal created from a vector that has boolean values
    Args:
        vector: Vector with indicator values. Must be the same length as strategy timestamps 
    '''
    vector: np.ndarray
    
    def __call__(self,
                 contract_group: ContractGroup, 
                 timestamps: np.ndarray, 
                 indicator_values: SimpleNamespace,
                 parent_values: SimpleNamespace,
                 context: StrategyContextType) -> np.ndarray:
        return self.vector

    
def get_contract_price_from_dict(price_dict: dict[str, dict[np.datetime64, float]], 
                                 contract: pq.Contract,
                                 timestamp: np.datetime64) -> float:               
    assert_(contract.symbol in price_dict, f'{contract.symbol} not found in price_dict')
    ret = price_dict[contract.symbol].get(timestamp)
    if ret is None: return math.nan
    return ret


def get_contract_price_from_array_dict(price_dict: dict[str, tuple[np.ndarray, np.ndarray]], 
                                       contract: pq.Contract, 
                                       timestamp: np.datetime64) -> float:
    tup: tuple[np.ndarray, np.ndarray] | None = price_dict.get(contract.symbol)
    assert_(tup is not None, f'{contract.symbol} not found in price_dict')
    _timestamps: np.ndarray = tup[0]  # type: ignore
    idx = np_indexof_sorted(_timestamps, timestamp)
    if idx == -1: return math.nan
    return tup[1][idx]  # type: ignore
    

@dataclass
class PriceFuncArrayDict:
    '''
    A function object with a signature of PriceFunctionType and takes a dictionary of 
        contract name -> tuple of sorted timestamps and prices
    >>> timestamps = np.arange(np.datetime64('2023-01-01'), np.datetime64('2023-01-04'))
    >>> price_dict = {'AAPL': (timestamps, [8, 9, 10]), 'IBM': (timestamps, [20, 21, 22])}
    >>> pricefunc = PriceFuncArrayDict(price_dict)
    >>> pq.Contract.clear()
    >>> pq.ContractGroup.clear()
    >>> cg = pq.ContractGroup.create('AAPL')
    >>> aapl = pq.Contract.create('AAPL', contract_group=cg)
    >>> assert(pricefunc(aapl, timestamps, 2, None) == 10)
    >>> ibm = pq.Contract.create('IBM', contract_group=cg)
    >>> basket = pq.Contract.create('AAPL_IBM', cg, components=[(aapl, 1), (ibm, -1)])
    >>> assert(pricefunc(basket, timestamps, 1, None) == -12)
    '''
    price_dict: dict[str, tuple[np.ndarray, np.ndarray]]
        
    def __init__(self, price_dict: dict[str, tuple[np.ndarray, np.ndarray]]) -> None:
        self.price_dict = price_dict
        
    def __call__(self, contract: Contract, timestamps: np.ndarray, i: int, context: StrategyContextType) -> float:
        price: float = 0.
        timestamp = timestamps[i]
        if contract.is_basket():
            for _contract, ratio in contract.components:
                price += get_contract_price_from_array_dict(self.price_dict, _contract, timestamp) * ratio
        else:
            price = get_contract_price_from_array_dict(self.price_dict, contract, timestamp)
        return price
    
    
@dataclass
class PriceFuncDict:
    '''
    A function object with a signature of PriceFunctionType and takes a dictionary of contract name -> timestamp -> price
    >>> timestamps = np.arange(np.datetime64('2023-01-01'), np.datetime64('2023-01-04'))
    >>> aapl_prices = [8, 9, 10]
    >>> ibm_prices = [20, 21, 22]
    >>> price_dict = {'AAPL': {}, 'IBM': {}} 
    >>> for i, timestamp in enumerate(timestamps):
    ...    price_dict['AAPL'][timestamp] = aapl_prices[i]
    ...    price_dict['IBM'][timestamp] = ibm_prices[i]
    >>> pricefunc = PriceFuncDict(price_dict)
    >>> pq.Contract.clear()
    >>> pq.ContractGroup.clear()
    >>> cg = pq.ContractGroup.create('AAPL')
    >>> aapl = pq.Contract.create('AAPL', contract_group=cg)
    >>> assert(pricefunc(aapl, timestamps, 2, None) == 10)
    >>> ibm = pq.Contract.create('IBM', contract_group=cg)
    >>> basket = pq.Contract.create('AAPL_IBM', cg, components=[(aapl, 1), (ibm, -1)])
    >>> assert(pricefunc(basket, timestamps, 1, None) == -12)
    '''
    price_dict: dict[str, dict[np.datetime64, float]]
        
    def __init__(self, price_dict: dict[str, dict[np.datetime64, float]]) -> None:
        self.price_dict = price_dict
        
    def __call__(self, contract: Contract, timestamps: np.ndarray, i: int, context: StrategyContextType) -> float:
        timestamp = timestamps[i]
        price: float = 0.
        if contract.is_basket():
            for _contract, ratio in contract.components:
                price += get_contract_price_from_dict(self.price_dict, _contract, timestamp) * ratio
        else:
            price = get_contract_price_from_dict(self.price_dict, contract, timestamp)
        return price
    

@dataclass
class SimpleMarketSimulator:
    '''
    A function object with a signature of MarketSimulatorType.
    It can take into account slippage and commission
    '''
    slippage: float
    price_func: PriceFunctionType
        
    def __init__(self,
                 price_func: PriceFunctionType,
                 slippage_per_trade: float = 0.,) -> None:
        '''
        Args:
            price_func: A function that we use to get the price to execute at
            slippage_per_trade: Slippage in local currency. Meant to simulate the difference
            between bid/ask mid and execution price 
        '''
    
        self.price_func = price_func
        self.slippage = slippage_per_trade
    
    def __call__(self,
                 orders: Sequence[Order],
                 i: int, 
                 timestamps: np.ndarray, 
                 indicators: dict[ContractGroup, SimpleNamespace],
                 signals: dict[ContractGroup, SimpleNamespace],
                 strategy_context: SimpleNamespace) -> list[Trade]:
        '''TODO: code for limit orders and stop orders'''
        trades = []
        timestamp = timestamps[i]
        # _logger.info(f'got: {orders}')
        for order in orders:
            if isinstance(order, VWAPOrder): continue
            if order.contract.is_basket(): continue
            slippage = self.slippage
            if order.qty < 0:
                slippage = -slippage
            raw_price = self.price_func(order.contract, timestamps, i, strategy_context)
            if np.isnan(raw_price): continue
            price = raw_price + slippage
            trade = Trade(order.contract, order, timestamp, order.qty, price)
            _logger.info(f'Trade: {timestamp.astype("M8[m]")} {trade}')
            order.fill()
            trades.append(trade)
        return trades
    

@dataclass
class PercentOfEquityTradingRule:
    '''
    A rule that trades a percentage of equity.
    Args:
        reason_code: Reason for entering the order, used for display
        equity_percent: Percentage of equity used to size order
        long: Whether We want to go long or short
        limit_increment: If not nan, we add or subtract this number from current market price (if selling or buying respectively)
            and create a limit order. If nan, we create market orders
        price_func: The function we use to get intraday prices
        direction_func: A function that takes a contract rule and self.long and returns 1 or -1. Useful for trading a basket 
            where going long the basket may mean, for example, going long equity A and B and short equity C
    '''
    
    reason_code: str
    equity_percent: float = 0.1  # use 10% of equity by default
    long: bool = True
    limit_increment: float = math.nan
    price_func: PriceFunctionType = None
    direction_func: Callable[[ContractGroup, bool], int] | None = None
        
    def __call__(self,
                 contract_group: ContractGroup,
                 i: int,
                 timestamps: np.ndarray,
                 indicator_values: SimpleNamespace,
                 signal_values: SimpleNamespace,
                 account: Account,
                 current_orders: Sequence[Order],
                 strategy_context: StrategyContextType) -> list[Order]:
        
        timestamp = timestamps[i]
            
        contract = contract_group.get_contract(contract_group.name)
        entry_price_est = self.price_func(contract, timestamps, i, strategy_context)
        if math.isnan(entry_price_est): return []
        
        curr_equity = account.equity(timestamp)
        risk_amount = self.equity_percent * curr_equity
        _order_qty = risk_amount / entry_price_est
        if self.direction_func:
            _order_qty *= self.direction_func(contract_group, self.long)
        elif not self.long:
            _order_qty *= -1
            
        order_qty = math.floor(_order_qty) if _order_qty > 0 else math.ceil(_order_qty)
        if math.isclose(order_qty, 0.): return []
        if math.isfinite(self.limit_increment):
            contract = contract_group.get_contract(contract_group.name)
            entry_price_est = self.price_func(contract, timestamps, i, strategy_context)
            if order_qty >= 0:
                entry_price_est -= self.limit_increment
            else:
                entry_price_est -= self.limit_increment
            limit_order = LimitOrder(contract=contract, 
                                     timestamp=timestamp, 
                                     qty=order_qty, 
                                     limit_price=entry_price_est, 
                                     reason_code=self.reason_code)
            return [limit_order]
        
        market_order = MarketOrder(contract=contract, timestamp=timestamp, qty=order_qty, reason_code=self.reason_code)
        return [market_order]

    
@dataclass(kw_only=True)
class VWAPOrder(Order):
    '''
    An order type to trade at VWAP. A vwap order executes at VWAP from the point it is sent to the market
    till the vwap end time specified in the order.

    Args:
        vwap_stop: limit price. If market price <= vwap_stop for buys or market price
        >= vwap_stop for sells, the order is executed at that point.
        vwap_end_time: We want to execute at VWAP computed from now to this time
    '''
    vwap_stop: float = math.nan
    vwap_end_time: np.datetime64
        
    def __repr__(self):
        timestamp = pd.Timestamp(self.timestamp).to_pydatetime()
        return (f'{self.contract.symbol} {timestamp:%Y-%m-%d %H:%M:%S} '
                f'limit: {self.vwap_stop:.3f} end: {self.vwap_end_time} qty: {self.qty}'
                + ('' if self.reason_code == ReasonCode.NONE else f' {self.reason_code}')
                + ('' if not self.properties.__dict__ else f' {self.properties}')
                + f' {self.status}')
    
    
@dataclass
class VWAPEntryRule:
    '''
    A rule that generates VWAP orders
    Args:
        reason_code: Reason for each order. For display purposes
        vwap_minutes: How long the vwap period is. For example, a 5 minute vwap order will execute at 5 minute vwap 
        from when it is sent to the market
        price_func: A function that this rule uses to get market price at a given timestamp
        long: Whether we want to go long or short
        percent_of_equity: Order qty is calculated so that if the stop price is reached, we lose this amount
        stop_price_ind: Don't enter if estimated entry price is 
            market price <= stop price + min_price_diff (for long orders) or the opposite for short orders
        min_price_diff: See stop_price_ind
    '''
    reason_code: str
    vwap_minutes: int
    price_func: PriceFunctionType
    long: bool
    percent_of_equity: float
    stop_price_ind: str | None
    min_price_diff: float
    single_entry_per_day: bool
        
    def __init__(self, 
                 reason_code: str,
                 vwap_minutes: int,
                 price_func: PriceFunctionType,
                 long: bool = True,
                 percent_of_equity: float = 0.1,
                 stop_price_ind: str | None = None,
                 min_price_diff: float = 0,
                 single_entry_per_day: bool = False) -> None:
        self.reason_code = reason_code
        self.price_func = price_func
        self.long = long
        self.vwap_minutes = vwap_minutes
        self.percent_of_equity = percent_of_equity
        self.stop_price_ind = stop_price_ind
        self.min_price_diff = min_price_diff
        self.single_entry_per_day = single_entry_per_day
        
    def __call__(self,
                 contract_group: ContractGroup,
                 i: int,
                 timestamps: np.ndarray,
                 indicator_values: SimpleNamespace,
                 signal_values: SimpleNamespace,
                 account: Account,
                 current_orders: Sequence[Order],
                 strategy_context: StrategyContextType) -> list[Order]:
        timestamp = timestamps[i]
        if self.single_entry_per_day:
            date = timestamp.astype('M8[D]')
            trades = account.get_trades_for_date(contract_group.name, date)
            if len(trades): return []
            
        for order in current_orders:
            if order.contract.contract_group == contract_group and order.is_open(): return []

        contract = contract_group.get_contract(contract_group.name)
        entry_price_est = self.price_func(contract, timestamps, i, strategy_context)
        if math.isnan(entry_price_est): return []
        
        if self.stop_price_ind:
            _stop_price_ind = getattr(indicator_values, self.stop_price_ind)
            stop_price = _stop_price_ind[i]
            if self.long and (entry_price_est - stop_price) < self.min_price_diff: return []
            if not self.long and (stop_price - entry_price_est) < self.min_price_diff: return []
        else:
            stop_price = math.nan
        
        curr_equity = account.equity(timestamp)
        risk_amount = self.percent_of_equity * curr_equity
        _order_qty = risk_amount / (entry_price_est - stop_price)
        order_qty = math.floor(_order_qty) if _order_qty > 0 else math.ceil(_order_qty)
        if math.isclose(order_qty, 0.): return []
        vwap_end_time = timestamp + np.timedelta64(self.vwap_minutes, 'm')
        order = VWAPOrder(contract=contract, 
                          timestamp=timestamp, 
                          vwap_stop=stop_price,
                          vwap_end_time=vwap_end_time, 
                          qty=order_qty, 
                          time_in_force=TimeInForce.GTC,
                          reason_code=self.reason_code)
        return [order]
    
    
@dataclass
class VWAPCloseRule:
    '''
    Rule to close out a position at vwap price
    Args:
        reason_code: Reason_code: Reason for each order. For display purposes
        vwap_minutes: How long the vwap period is. For example, a 5 minute vwap order will execute at 5 minute vwap
    '''
    reason_code: str
    vwap_minutes: int
        
    def __init__(self, 
                 vwap_minutes: int,
                 reason_code: str) -> None:
        self.vwap_minutes = vwap_minutes
        self.reason_code = reason_code
        
    def __call__(self,
                 contract_group: ContractGroup,
                 i: int,
                 timestamps: np.ndarray,
                 indicator_values: SimpleNamespace,
                 signal_values: SimpleNamespace,
                 account: Account,
                 current_orders: Sequence[Order],
                 strategy_context: StrategyContextType) -> list[Order]:
        timestamp = timestamps[i]
        for order in current_orders:
            if order.contract.contract_group == contract_group and order.is_open(): return []
        positions = account.positions(contract_group, timestamp)
        assert len(positions) == 1, f'expected 1 positions, got: {positions}'
        (contract, qty) = positions[0]
        vwap_end_time = timestamp + np.timedelta64(self.vwap_minutes, 'm')
        order = VWAPOrder(contract=contract, 
                          timestamp=timestamp, 
                          vwap_end_time=vwap_end_time, 
                          qty=-qty, 
                          time_in_force=TimeInForce.GTC,
                          reason_code=self.reason_code)
        return [order]


@dataclass    
class VWAPMarketSimulator:
    '''
    A market simulator that simulates buying and selling at VWAP prices.
    This works with VWAP orders and ignores all other order types
    The order executes either:
    a. After the vwap end time defined in the VWAP order
    b. If marker price <= vwap stop price defined in the VWAP order for buy orders
    c. If market price >= vwap stop price for sell orders
    '''
    price_indicator: str
    volume_indicator: str
    backup_price_indicator: str | None

    def __init__(self,
                 price_indicator: str,
                 volume_indicator: str,
                 backup_price_indicator: str | None = None) -> None:
        '''
        Args:
            price_indicator: An indicator that contains historical trade price per timestamp
            volume_indicator: An indicator that contains volume per timestamp
            backup_price_indicator: Execution price to use if price or volume is missing
        '''
        self.price_indicator = price_indicator
        self.volume_indicator = volume_indicator
        self.backup_price_indicator = backup_price_indicator
    
    def __call__(self,
                 orders: Sequence[Order], 
                 i: int, 
                 timestamps: np.ndarray, 
                 indicators: dict[ContractGroup, SimpleNamespace],
                 signals: dict[ContractGroup, SimpleNamespace],
                 strategy_context: SimpleNamespace) -> list[Trade]:
        trades = []
        timestamp = timestamps[i]
        for order in orders:
            if not isinstance(order, VWAPOrder): continue
            cg = order.contract.contract_group
            inds = indicators.get(cg)
            assert_(inds is not None, f'indicators not found for contract group: {cg} {timestamp} {i}')
            price_ind = getattr(inds, self.price_indicator)  # type: ignore
            assert_(price_ind is not None, f'indicator: {self.price_indicator} not found for contract group: {cg} {timestamp} {i}')
            volume_ind = getattr(inds, self.volume_indicator)  # type: ignore
            assert_(volume_ind is not None, f'indicator: {self.volume_indicator} not found for contract group: {cg} {timestamp} {i}')
            end_order = False
            if math.isfinite(order.vwap_stop) and (
                    (order.qty >= 0 and price_ind[i] <= order.vwap_stop) or (order.qty < 0 and price_ind[i] >= order.vwap_stop)):
                end_order = True
            if not end_order and timestamp < order.vwap_end_time and i != len(timestamps) - 1 \
                    and not timestamps[i + 1].astype('M8[D]') > timestamps[i].astype('M8[D]'):
                continue
            mask = (price_ind > 0) & (volume_ind > 0)
            if end_order:
                mask &= (timestamps >= order.timestamp) & (timestamps <= timestamp)
            else:
                mask &= (timestamps >= order.timestamp) & (timestamps <= order.vwap_end_time)
            amt = price_ind[mask] * volume_ind[mask]
            if not len(amt):
                if order.qty <= 0: continue
                _logger.info(f'using backup price for {cg} {timestamp} {i} qty: {order.qty} {order}')
                assert_(self.backup_price_indicator is not None, 
                        f'backup price indicator not found and no vwap found for: {cg} {timestamp} {i}')
                _backup_price_ind = getattr(inds, self.backup_price_indicator)  # type: ignore
                assert_(_backup_price_ind is not None, f'backup price indicator not found for: {cg} {timestamp} {i}')
                vwap = _backup_price_ind[i]
            else:
                vwap = np.sum(amt) / np.sum(volume_ind[mask])
            assert_(vwap >= 0)
            fill_qty = order.qty
            if end_order:
                fill_fraction = (timestamp - order.timestamp) / (order.vwap_end_time - order.timestamp)
                fill_fraction = min(fill_fraction, 1)
                fill_qty = np.fix(order.qty * fill_fraction)
                _logger.info(f'{timestamp} {order.timestamp} {order.vwap_end_time} {fill_fraction} qty: {fill_qty}')
            order.fill(fill_qty)
            order.cancel()
            trade = Trade(order.contract, order, timestamp, fill_qty, vwap)
            _logger.info(f'Trade: {timestamp.astype("M8[m]")} {trade} {i}')
            trades.append(trade)
        return trades


@dataclass
class FiniteRiskEntryRule:
    '''
    A rule that generates orders with stops
    Args:
        reason_code: Reason for the orders created used for display
        price_func: A function that returns price given a contract and timestamp
        long: whether we want to go long or short
        percent_of_equity: How much to risk per trade as a percentage of current equity.
            Used to calculate order qty so that if we get stopped out, we don't lose 
            more than this amount. Of course if price gaps up or down rather than moving smoothly,
            we may lose more.
        stop_price_ind: An indicator containing the stop price so we exit the order when this is breached
    '''
    reason_code: str
    price_func: PriceFunctionType
    long: bool
    percent_of_equity: float
    stop_price_ind: str | None
    min_price_diff: float
    single_entry_per_day: bool
        
    def __init__(self, 
                 reason_code: str, 
                 price_func: PriceFunctionType,
                 long: bool = True,
                 percent_of_equity: float = 0.1,
                 stop_price_ind: str | None = None,
                 min_price_diff: float = 0,
                 single_entry_per_day: bool = False) -> None:
        self.reason_code = reason_code
        self.price_func = price_func
        self.long = long
        self.percent_of_equity = percent_of_equity
        self.stop_price_ind = stop_price_ind
        self.min_price_diff = min_price_diff
        self.single_entry_per_day = single_entry_per_day
        
    def __call__(self,
                 contract_group: ContractGroup,
                 i: int,
                 timestamps: np.ndarray,
                 indicator_values: SimpleNamespace,
                 signal_values: SimpleNamespace,
                 account: Account,
                 current_orders: Sequence[Order],
                 strategy_context: StrategyContextType) -> list[Order]:
        timestamp = timestamps[i]
        if self.single_entry_per_day:
            date = timestamp.astype('M8[D]')
            trades = account.get_trades_for_date(contract_group.name, date)
            if len(trades): return []

        contract = contract_group.get_contract(contract_group.name)
        entry_price_est = self.price_func(contract, timestamps, i, strategy_context)
        if math.isnan(entry_price_est): return []
        
        if self.stop_price_ind:
            _stop_price_ind = getattr(indicator_values, self.stop_price_ind)
            stop_price = _stop_price_ind[i]
        else:
            stop_price = 0.

        if self.long and (entry_price_est - stop_price) < self.min_price_diff: return []
        if not self.long and (stop_price - entry_price_est) < self.min_price_diff: return []
        
        curr_equity = account.equity(timestamp)
        risk_amount = self.percent_of_equity * curr_equity
        _order_qty = risk_amount / (entry_price_est - stop_price)
        order_qty = math.floor(_order_qty) if _order_qty > 0 else math.ceil(_order_qty)
        if math.isclose(order_qty, 0.): return []
        order = MarketOrder(contract=contract, 
                            timestamp=timestamp, 
                            qty=order_qty,
                            reason_code=self.reason_code)
        return [order]
    

@dataclass
class ClosePositionExitRule:
    '''
    A rule to close out an open position
    Args:
        reason_code: the reason for closing out used for display purposes
        price_func: the function this rule uses to get market prices
        limit_increment: if not nan, we add or subtract this number from current market price (if selling or buying respectively)
            and create a limit order
        log_orders: if set, we use the python logger to log each order as it is generated
    '''
    reason_code: str
    price_func: PriceFunctionType
    limit_increment: float
        
    def __init__(self, 
                 reason_code: str, 
                 price_func: PriceFunctionType,
                 limit_increment: float = math.nan,
                 log_orders: bool = True) -> None:
        self.reason_code = reason_code
        self.price_func = price_func
        assert_(math.isnan(limit_increment) or limit_increment >= 0, 
                f'limit_increment: {limit_increment} cannot be negative')
        self.limit_increment = limit_increment
        self.log_orders = log_orders
        
    def __call__(self,
                 contract_group: ContractGroup,
                 i: int,
                 timestamps: np.ndarray,
                 indicator_values: SimpleNamespace,
                 signal_values: SimpleNamespace,
                 account: Account,
                 current_orders: Sequence[Order],
                 strategy_context: StrategyContextType) -> list[Order]:
        timestamp = timestamps[i]
        positions = account.positions(contract_group, timestamp)
        # assert len(positions) == 1, f'expected 1 positions, got: {positions}'
        orders: list[Order] = []
        for (contract, qty) in positions:
            if math.isfinite(self.limit_increment):
                exit_price_est = self.price_func(contract, timestamps, i, strategy_context)
                if qty >= 0:
                    exit_price_est += self.limit_increment
                else:
                    exit_price_est -= self.limit_increment
                limit_order = LimitOrder(contract=contract, timestamp=timestamp, qty=-qty, limit_price=exit_price_est, reason_code=self.reason_code)
                orders.append(limit_order)
                continue
            order = MarketOrder(contract=contract, timestamp=timestamp, qty=-qty, reason_code=self.reason_code)
            orders.append(order)
        if self.log_orders: _logger.info(f'ORDER: {timestamp} {order}')
        return orders
    

if __name__ == "__main__":
    import doctest
    doctest.testmod(optionflags=doctest.NORMALIZE_WHITESPACE | doctest.ELLIPSIS)
# $$_end_code
