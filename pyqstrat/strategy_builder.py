# $$_ Lines starting with # $$_* autogenerated by jup_mini. Do not modify these
# $$_markdown
# # Strategy Builder
# 
# ## Purpose
# Simplifies creation of simpler strategies by removing the need for a lot of boilerplate code
# $$_end_markdown
# $$_code
# $$_ %%checkall
import numpy as np
import pandas as pd
from dataclasses import dataclass
import math
from types import SimpleNamespace
from typing import Sequence, Any
from pyqstrat.account import Account
from pyqstrat.strategy import Strategy
from pyqstrat.pq_types import Contract, ContractGroup, Trade, Order
from pyqstrat.pq_types import MarketOrder, LimitOrder, TimeInForce, ReasonCode
from pyqstrat.strategy import PriceFunctionType, StrategyContextType, MarketSimulatorType
from pyqstrat.strategy import RuleType, IndicatorType, SignalType
from pyqstrat.pq_utils import assert_, get_child_logger


_logger = get_child_logger(__name__)

@dataclass
class StrategyBuilder:
    
    def __init__(self, data: pd.DataFrame | None = None) -> None:
        if data is not None: assert_(len(data) > 0, 'data cannot be empty')
        self.data: pd.DataFrame = data
        self.contract_groups: list[ContractGroup] = []
        self.price_function: PriceFunctionType | None = None
        self.timestamps: np.ndarray | None = None
        self.timestamp_unit: np.dtype = np.dtype('M8[m]')  # by default use minutes, unless set_timestamps is called
        self.pnl_calc_time: int = 16 * 60 + 1
        self.starting_equity: float = 1.0e6
        self.trade_lag: int = 1
        self.run_final_calc: bool = True
        self.strategy_context: SimpleNamespace = SimpleNamespace()
        self.indicators: list[tuple[
            str, IndicatorType, Sequence[ContractGroup] | None, Sequence[str] | None]] = []
        self.signals: list[tuple[
            str, SignalType, Sequence[ContractGroup] | None, Sequence[str] | None, Sequence[str] | None]] = []
        self.rules: list[tuple[str, RuleType, str, Sequence[Any] | None, str | None]] = []
        self.market_sims: list[MarketSimulatorType] = []
        
        Contract.clear()
        ContractGroup.clear()

    def set_timestamps(self, timestamps: np.ndarray) -> None:
        assert_(np.issubdtype(timestamps.dtype, np.datetime64), f'timestamps must be np.datetime64: {timestamps}')
        self.timestamps = timestamps
        
    def set_starting_equity(self, starting_equity: float) -> None:
        self.starting_equity = starting_equity
        
    def set_pnl_calc_time(self, pnl_calc_time: int) -> None:
        self.pnl_calc_time = pnl_calc_time
        
    def set_trade_lag(self, trade_lag: int) -> None:
        self.trade_lag = trade_lag
        
    def set_run_final_calc(self, run_final_calc: bool) -> None:
        self.run_final_calc = run_final_calc
        
    def set_strategy_context(self, context: StrategyContextType) -> None:
        self.strategy_context = context
        
    def add_contract(self, symbol: str) -> None:
        cg = ContractGroup.create(symbol)
        Contract.create(symbol, cg)
        self.contract_groups.append(cg)
        
    def set_price_function(self, price_function: PriceFunctionType) -> None:
        self.price_function = price_function
        
    def add_contract_group(self, contract_group: ContractGroup) -> None:
        self.contract_groups.append(contract_group)
    
    def add_indicator(self, 
                      name: str, 
                      indicator: IndicatorType, 
                      contract_groups: Sequence[ContractGroup] | None = None, 
                      depends_on: Sequence[str] | None = None) -> None:
        self.indicators.append((name, indicator, contract_groups, depends_on))
        
    def add_signal(self,
                   name: str,
                   signal_function: SignalType,
                   contract_groups: Sequence[ContractGroup] | None = None,
                   depends_on_indicators: Sequence[str] | None = None,
                   depends_on_signals: Sequence[str] | None = None) -> None:
        self.signals.append((name, signal_function, contract_groups, depends_on_indicators, depends_on_signals))
        
    def add_rule(self,
                 name: str, 
                 rule_function: RuleType, 
                 signal_name: str, 
                 sig_true_values: Sequence[Any] | None = None, 
                 position_filter: str | None = None) -> None:
        self.rules.append((name, rule_function, signal_name, sig_true_values, position_filter))
        
    def add_market_sim(self, market_sim_function: MarketSimulatorType) -> None:
        self.market_sims.append(market_sim_function)
        
    def add_vector_rule(self,
                        column_name: str, 
                        rule_function: RuleType,
                        position_filter: str) -> None:
        assert_(self.data is not None, 'data cannot be None when adding rule by name')
        assert_(column_name in self.data.columns, f'{column_name} not found in data: {self.data.columns}')
        ind_name, sig_name = f'{column_name}_ind', f'{column_name}_sig'
        self.indicators.append((ind_name, self.data[column_name].values, None, None))
        self.signals.append((sig_name, VectorSignal(ind_name), None, [ind_name], None))
        self.rules.append((column_name, rule_function, sig_name, None, position_filter))

    def __call__(self) -> Strategy:
        assert_(len(self.contract_groups) > 0, 'contract_groups cannot be empty')
        assert_(self.price_function is not None, 'price function must be set')
        if self.timestamps is None:
            assert_(self.data is not None, 'data cannot be None if timestamps is not set')
        _timestamps = self.data['timestamp'].values.astype(self.timestamp_unit) if self.timestamps is None else self.timestamps
        
        strat = Strategy(_timestamps, 
                         self.contract_groups, 
                         self.price_function,  # type: ignore
                         self.starting_equity, 
                         self.pnl_calc_time, 
                         self.trade_lag, 
                         self.run_final_calc, 
                         self.strategy_context)
        
        assert_(self.rules is not None and len(self.rules) > 0, 'rules cannot be empty or None')
        for name, indicator, contract_groups, depends_on in self.indicators:
            strat.add_indicator(name, indicator, contract_groups, depends_on)
             
        for name, signal_function, contract_groups, depends_on_inds, depends_on_sigs in self.signals:
            strat.add_signal(name, signal_function, contract_groups, depends_on_inds, depends_on_sigs)
            
        for name, rule_function, signal_name, sig_true_values, position_filter in self.rules:
            strat.add_rule(name, rule_function, signal_name, sig_true_values, position_filter)
        
        if not len(self.market_sims):
            strat.add_market_sim(SimpleMarketSimulator(self.price_function))  # type: ignore
        else:
            for market_sim in self.market_sims:
                strat.add_market_sim(market_sim)
            
        return strat

# $$_end_code
